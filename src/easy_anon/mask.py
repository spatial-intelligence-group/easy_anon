#!/usr/bin/env python3


"""Generate masks for the given images using Mask2Former."""

import argparse
import os
import importlib.resources
import numpy as np
import cv2
from rich.progress import track
from rich.console import Console
import yaml

try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

from detectron2.config import get_cfg
from detectron2.data.detection_utils import read_image
from detectron2.projects.deeplab import add_deeplab_config
from detectron2.engine.defaults import DefaultPredictor

from mask2former.config import add_maskformer2_config

# Registers the MaskFormer model with Detectron at import time - has to be imported even if not used
from mask2former import maskformer_model  # noqa: F401

from easy_anon.utils import IMG_EXTS, MODELS, LABELS_CHOICES, LABELS_FILES, DEFAULT_CACHE_DIR


def main():
    """Generate binary masks for the given images and selected labels using Mask2Former."""
    parser = argparse.ArgumentParser(
        description="Masking / anonymization using Mask2Former",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--input",
        type=str,
        required=True,
        help="Path to the input image / image directory",
    )
    parser.add_argument(
        "--output",
        type=str,
        required=True,
        help="Path to the output binary mask / directory for masks",
    )
    parser.add_argument(
        "--labels",
        type=str,
        nargs="+",
        default=["person", "vehicle"],
        choices=LABELS_CHOICES,
        help="Label groups to mask. Check the labels files in the configs directory for more info.",
    )
    parser.add_argument(
        "--model",
        type=str,
        nargs="+",
        default=["MapillaryVistas-ResNet50", "MapillaryVistas-Swin-L-IN21k"],
        choices=MODELS.keys(),
        help="Mask2Former model / a list of models to use",
    )
    parser.add_argument(
        "--save_model_masks",
        action="store_true",
        help="Save the masks generated by each model separately, apart from merging them into a single mask",
    )
    parser.add_argument(
        "--mask_color_mode",
        type=str,
        default="black_on_white",
        choices=["black_on_white", "white_on_black"],
        help="Color mode for the generated masks. "
        "If 'black_on_white', the mask will be black on a white background. "
        "If 'white_on_black', the mask will be white on a black background.",
    )
    parser.add_argument(
        "--mask_merge_mode",
        type=str,
        default="union",
        choices=["union", "intersection"],
        help="How to merge the masks generated by different models. "
        "If 'union', the masks will be combined using a bitwise OR operation. "
        "If 'intersection', the masks will be combined using a bitwise AND operation.",
    )
    parser.add_argument(
        "--existing_mask_mode",
        type=str,
        default="overwrite",
        choices=["overwrite", "merge"],
        help="How to handle existing masks in the output directory. "
        "If 'overwrite', the existing masks will be overwritten. "
        "If 'merge', the existing and new masks will be merged using the specified --mask_merge_mode option.",
    )
    parser.add_argument(
        "--checkpoint_dir",
        type=str,
        default=DEFAULT_CACHE_DIR,
        help="Path of the directory where the checkpoint files are cached",
    )
    args = parser.parse_args()

    if os.path.isfile(args.input):
        input_image_list = [args.input]
    elif os.path.isdir(args.input):
        input_image_list = [
            os.path.join(args.input, f) for f in os.listdir(args.input) if os.path.splitext(f)[1].lower() in IMG_EXTS
        ]
    else:
        raise ValueError(f"The given input path does not exist: {args.input}")

    console = Console()
    init_run = True

    for model in args.model:
        config_file = MODELS[model]["config"]

        model_url = MODELS[model]["model_url"]
        checkpoint_path = os.path.join(args.checkpoint_dir, model + ".pkl")
        if not os.path.isfile(checkpoint_path):
            download_checkpoint(model_url, checkpoint_path)

        config_file_tmp_list = create_tmp_config(config_file, checkpoint_path=checkpoint_path)
        config_file_tmp_path = config_file_tmp_list[-1]  # Use the last one as the top-level config file

        cfg = setup_cfg(config_file_tmp_path)

        predictor = DefaultPredictor(cfg)
        for config_file_tmp_path in config_file_tmp_list:
            os.remove(config_file_tmp_path)

        labels_file = LABELS_FILES[model.split("-")[0]]
        labels_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), labels_file)
        labels_all = yaml.safe_load(open(labels_path))
        labels = []
        for label_category in args.labels:
            label_category_ids = labels_all[label_category]
            if not label_category_ids:
                console.print(
                    f":warning: The model '{model}' does not support the label category '{label_category}'."
                    f"Check the available label categories in {labels_path}.",
                    style="yellow",
                )
            else:
                labels.extend(label_category_ids)

        for input_image_path in track(input_image_list, description=f"Generating masks with {model}..."):
            img = read_image(input_image_path, format="BGR")
            predictions = predictor(img)
            mask_img = create_mask(predictions, labels, args.mask_color_mode)

            os.makedirs(os.path.dirname(args.output), exist_ok=True)

            # Save the masks generated by each model separately
            if args.save_model_masks:
                mask_output_path = os.path.join(
                    args.output, os.path.splitext(os.path.basename(input_image_path))[0] + "_" + model + ".png"
                )
                cv2.imwrite(mask_output_path, mask_img)

            # Save the masks merged from all models
            merged_mask_path = os.path.join(
                args.output, os.path.splitext(os.path.basename(input_image_path))[0] + ".png"
            )

            # Handle existing masks based on the value of --existing_mask_mode
            if init_run and os.path.isfile(merged_mask_path) and args.existing_mask_mode == "overwrite":
                os.remove(merged_mask_path)

            if os.path.isfile(merged_mask_path):
                merged_mask = cv2.imread(merged_mask_path, cv2.IMREAD_UNCHANGED)
                if merged_mask.shape[:2] != mask_img.shape[:2]:
                    raise ValueError(f"Mask shape mismatch: {merged_mask.shape} vs {mask_img.shape}")

                # Use "XNOR" logical operation to find the correct operation for mask merging
                # - union + white_on_black = OR
                # - union + black_on_white = AND
                # - intersection + white_on_black = AND
                # - intersection + black_on_white = OR
                if (args.mask_merge_mode == "union") == (args.mask_color_mode == "black_on_white"):
                    merged_mask = cv2.bitwise_and(merged_mask, mask_img)
                else:
                    merged_mask = cv2.bitwise_or(merged_mask, mask_img)
            else:
                merged_mask = mask_img
            cv2.imwrite(merged_mask_path, merged_mask)

        init_run = False


def create_tmp_config(config_path, checkpoint_path=None, recursion_depth=0):
    """Create a temporary file based on a config file from Mask2Former.

    The Mask2Former configs are installed within the mask2former package. Copy the config file to a temporary location
    and return the path so it can be loaded by detectron2.

    Args:
        config_path (str): The path to the config file relative to the config directory in Mask2Former package.
        checkpoint_path (str, optional): Path to the model checkpoint file. If provided, it will replace the "WEIGHTS"
        key in the config.
        recursion_depth (int): Used for recursive base config resolution.

    Returns:
        list: A list of paths to the temporary config files created, including the base configs if any. The top-level
        config file is the last one in the list.
    """
    package = "mask2former.configs"

    with importlib.resources.files(package).joinpath(config_path).open("r") as f:
        # Not using safe load due to math functions (python/object/apply:eval) in the config files
        yaml_data = yaml.load(f, Loader=Loader)

    tmp_yaml_path = os.path.join(os.path.dirname(__file__), f"tmp_config_{recursion_depth}.yaml")

    if "_BASE_" in yaml_data:
        base_config_relpath = yaml_data["_BASE_"]
        base_config_path = os.path.join(os.path.dirname(config_path), base_config_relpath)
        tmp_yaml_path_list = create_tmp_config(base_config_path, recursion_depth=recursion_depth + 1)
        yaml_data["_BASE_"] = tmp_yaml_path_list[-1]
    else:
        tmp_yaml_path_list = []

    if checkpoint_path is not None:
        yaml_data["MODEL"]["WEIGHTS"] = checkpoint_path

    with open(tmp_yaml_path, "w") as f:
        yaml.dump(yaml_data, f, Dumper=Dumper)

    tmp_yaml_path_list.append(tmp_yaml_path)

    return tmp_yaml_path_list


def setup_cfg(input_config):
    """Setup the configuration for Mask2Former using the given input config file or list.

    Args:
        input_config (str, list, dict): Path to the config file, a list of config options (interleaved key,value),
        or a dictionary of config options.

    Returns:
        cfg (CfgNode): The Detectron2 configuration object with the given settings.
    """
    cfg = get_cfg()
    add_deeplab_config(cfg)
    add_maskformer2_config(cfg)

    if isinstance(input_config, str):
        cfg.merge_from_file(input_config)
    elif isinstance(input_config, list):
        cfg.merge_from_list(input_config)
    elif isinstance(input_config, dict):
        config_list = []
        for k, v in input_config.items():
            config_list.append(k)
            config_list.append(v)
        cfg.merge_from_list(config_list)

    cfg.freeze()
    return cfg


def create_mask(predictions, labels, color_mode="black_on_white"):
    """Create a binary mask image from the raw Mask2Former predictions.

    Args:
        predictions (dict): The raw predictions from the Mask2Former model, containing semantic segmentation results.
        labels (list): A list of label IDs to include in the mask.
        color_mode (str): The color mode for the mask image. Can be "black_on_white" or "white_on_black".

    Returns:
        np.ndarray: A binary mask image.
    """
    assert "sem_seg" in predictions, "The predictions must contain 'sem_seg' key with semantic segmentation results."

    segmentation = predictions["sem_seg"].argmax(dim=0).to("cpu").numpy()
    mask_bool = np.isin(segmentation, labels).reshape(segmentation.shape)
    if color_mode == "black_on_white":
        mask_bool = np.logical_not(mask_bool)
    mask_img = mask_bool.astype(np.uint8) * 255
    return mask_img


def download_checkpoint(url: str, dest: str):
    """Download a model checkpoint from the given URL to the specified destination.

    Args:
        url (str): The URL to download the checkpoint from.
        dest (str): The destination path where the checkpoint will be saved.
    """
    import subprocess

    os.makedirs(os.path.dirname(dest), exist_ok=True)
    subprocess.run(["wget", url, "-O", str(dest)], check=True)


if __name__ == "__main__":
    main()
