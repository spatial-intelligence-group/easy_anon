#!/usr/bin/env python3


"""Generate masks for the given images using Mask2Former.

This file includes code derived from the Mask2Former demo by Meta, Inc.
https://github.com/facebookresearch/Mask2Former
Licensed under the MIT License.
Copyright (c) 2022 Meta, Inc.
"""

import argparse
from rich_argparse import ArgumentDefaultsRichHelpFormatter
import os
import importlib.resources
import numpy as np
import cv2
import yaml
import tempfile

try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

from detectron2.config import get_cfg
from detectron2.data.detection_utils import read_image
from detectron2.projects.deeplab import add_deeplab_config
from detectron2.engine.defaults import DefaultPredictor

from mask2former.config import add_maskformer2_config

# Registers the MaskFormer model with Detectron at import time - has to be imported even if not used
from mask2former import maskformer_model  # noqa: F401

from easy_anon.utils import (
    MODELS,
    IMG_EXTS,
    LABELS_CHOICES,
    LABELS_FILES,
    DEFAULT_CACHE_DIR,
    check_img_ext,
    load_mask,
    save_mask,
    download_checkpoint,
    get_rich_console,
    get_rich_progress_processing,
    get_rich_argparse_style,
    get_unique_string,
)


def main():
    """Generate binary masks for the given images and selected labels using Mask2Former."""
    ArgumentDefaultsRichHelpFormatter.styles = get_rich_argparse_style()
    parser = argparse.ArgumentParser(
        description="Generating binary masks with Mask2Former.",
        formatter_class=ArgumentDefaultsRichHelpFormatter,
    )
    parser.add_argument(
        "input_image",
        type=str,
        help="Path to the input image / image directory",
    )
    parser.add_argument(
        "output",
        type=str,
        help="Path to the output binary mask / directory for masks",
    )
    parser.add_argument(
        "--labels",
        type=str,
        nargs="+",
        default=["person", "vehicle"],
        choices=LABELS_CHOICES,
        help="Label groups to mask. Check the labels files in the configs directory for more info.",
    )
    parser.add_argument(
        "--model",
        type=str,
        nargs="+",
        default=["ADE20k-ResNet101", "ADE20k-Swin-L-IN21k"],
        choices=MODELS.keys(),
        help="Mask2Former model / a list of models to use",
    )
    parser.add_argument(
        "--save_model_masks",
        action="store_true",
        help="Save the masks generated by each model separately, apart from merging them into a single mask",
    )
    parser.add_argument(
        "--mask_color_mode",
        type=str,
        default="black_on_white",
        choices=["black_on_white", "white_on_black"],
        help="Color mode for the generated masks. "
        "If 'black_on_white', the mask will be black on a white background. "
        "If 'white_on_black', the mask will be white on a black background.",
    )
    parser.add_argument(
        "--dilation_radius",
        type=int,
        default=0,
        help="Radius of the dilation applied to the generated masks (inlfates the mask a bit).",
    )
    parser.add_argument(
        "--mask_postfix",
        type=str,
        default=".png",
        help="Postfix for the generated mask files. "
        "If the output is a directory, the mask files will be saved with this postfix."
        "Can be used to set a specific output image format by adding an extension to the postfix. ",
    )
    parser.add_argument(
        "--mask_merge_mode",
        type=str,
        default="union",
        choices=["union", "intersection"],
        help="How to merge the masks generated by different models. "
        "If 'union', the masks will be combined using a bitwise OR operation. "
        "If 'intersection', the masks will be combined using a bitwise AND operation.",
    )
    parser.add_argument(
        "--existing_mask_mode",
        type=str,
        default="overwrite",
        choices=["overwrite", "merge"],
        help="How to handle existing masks in the output directory. "
        "If 'overwrite', the existing masks will be overwritten. "
        "If 'merge', the existing and new masks will be merged using the specified --mask_merge_mode option.",
    )
    parser.add_argument(
        "--checkpoint_dir",
        type=str,
        default=DEFAULT_CACHE_DIR,
        help="Path of the directory where the checkpoint files are cached",
    )
    args = parser.parse_args()

    console = get_rich_console()

    img_is_file = os.path.isfile(args.input_image)
    img_is_dir = os.path.isdir(args.input_image)
    out_is_dir = os.path.isdir(args.output)

    if img_is_file:
        input_image_list = [args.input_image]
    elif img_is_dir:
        input_image_list = [os.path.join(args.input_image, f) for f in os.listdir(args.input_image) if check_img_ext(f)]
    else:
        raise ValueError(f"The given input path does not exist: {args.input_image}")

    if not input_image_list:
        raise ValueError(
            f"The given input image directory does not contain any valid image files: {args.input_image} "
            f"Supported image extensions are: {', '.join(IMG_EXTS)}"
        )

    if img_is_dir and not out_is_dir:
        raise ValueError(
            f"The output path must be a directory when the input image is a directory. Given output path: {args.output}"
        )

    if not out_is_dir:
        output_mask_list = [args.output]
    else:
        output_mask_list = []
        for f in input_image_list:
            img_base = os.path.splitext(os.path.basename(f))[0]
            mask_ext = (
                args.mask_postfix
                if args.mask_postfix and args.mask_postfix[0] == "."
                else os.path.splitext(args.mask_postfix)[1]
            )
            if mask_ext:
                output_mask_list.append(os.path.join(args.output, img_base + args.mask_postfix))
            else:
                output_mask_list.append(os.path.join(args.output, img_base + args.mask_postfix + ".png"))

    init_run = True
    init_warn = True

    for model in args.model:
        config_file = MODELS[model]["config"]

        model_url = MODELS[model]["model_url"]
        checkpoint_path = os.path.join(args.checkpoint_dir, model + ".pkl")
        if not os.path.isfile(checkpoint_path):
            download_checkpoint(model_url, checkpoint_path)

        config_file_tmp_list = create_tmp_config(config_file, checkpoint_path=checkpoint_path)
        config_file_tmp_path = config_file_tmp_list[-1]  # Use the last one as the top-level config file

        cfg = setup_cfg(config_file_tmp_path)

        predictor = DefaultPredictor(cfg)
        for config_file_tmp_path in config_file_tmp_list:
            os.remove(config_file_tmp_path)

        labels_file = LABELS_FILES[model.split("-")[0]]
        labels_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), labels_file)
        labels_all = yaml.safe_load(open(labels_path))
        labels = []
        for label_category in args.labels:
            label_category_ids = labels_all[label_category]
            if not label_category_ids:
                console.print(
                    f"Warning :warning: : The model '{model}' does not support the label category '{label_category}'."
                    f"Check the available label categories in {labels_path}.",
                    style="warning",
                )
            else:
                labels.extend(label_category_ids)

        progress = get_rich_progress_processing()
        progress.start()
        for idx in progress.track(range(len(input_image_list)), description=f"Generating masks with {model}"):
            input_image_path = input_image_list[idx]
            merged_mask_path = output_mask_list[idx]
            img = read_image(input_image_path, format="BGR")
            predictions = predictor(img)
            mask_img = create_mask(predictions, labels, dilation_radius=args.dilation_radius)

            os.makedirs(os.path.dirname(args.output), exist_ok=True)

            if init_warn and os.path.splitext(merged_mask_path)[1].lower() in [".jpg", ".jpeg"]:
                progress.console.print(
                    "Warning :warning: : Masks are being saved in JPEG format, which may cause compression artifacts. ",
                    style="warning",
                )
                init_warn = False

            # Save the masks generated by each model separately
            if args.save_model_masks:
                mask_base, mask_ext = os.path.splitext(merged_mask_path)
                mask_output_path = mask_base + "_" + model + mask_ext
                save_mask(mask_img, mask_output_path, mode=args.mask_color_mode)

            # Save the masks merged from all models
            if init_run and os.path.isfile(merged_mask_path) and args.existing_mask_mode == "overwrite":
                # Handle existing masks based on the value of --existing_mask_mode
                os.remove(merged_mask_path)

            if os.path.isfile(merged_mask_path):
                merged_mask = load_mask(merged_mask_path, mode=args.mask_color_mode)
                if merged_mask.shape[:2] != mask_img.shape[:2]:
                    raise ValueError(f"Mask shape mismatch: {merged_mask.shape} vs {mask_img.shape}")

                if args.mask_merge_mode == "union":
                    merged_mask = np.logical_or(merged_mask, mask_img)
                elif args.mask_merge_mode == "intersection":
                    merged_mask = np.logical_and(merged_mask, mask_img)
            else:
                merged_mask = mask_img
            save_mask(merged_mask, merged_mask_path, mode=args.mask_color_mode)
        progress.stop()

        init_run = False


def create_tmp_config(config_path, checkpoint_path=None):
    """Create a temporary file based on a config file from Mask2Former.

    The Mask2Former configs are installed within the mask2former package. Copy the config file to a temporary location
    and return the path so it can be loaded by detectron2.

    Args:
        config_path (str): The path to the config file relative to the config directory in Mask2Former package.
        checkpoint_path (str, optional): Path to the model checkpoint file. If provided, it will replace the "WEIGHTS"
        key in the config.

    Returns:
        list: A list of paths to the temporary config files created, including the base configs if any. The top-level
        config file is the last one in the list.
    """
    package = "mask2former.configs"

    with importlib.resources.files(package).joinpath(config_path).open("r") as f:
        # Not using safe load due to math functions (python/object/apply:eval) in the config files
        yaml_data = yaml.load(f, Loader=Loader)

    # Create a temporary file (with a random name) to store the config
    tmp_yaml_path = os.path.join(tempfile.gettempdir(), f"tmp_config_{get_unique_string()}.yaml")

    if "_BASE_" in yaml_data:
        base_config_relpath = yaml_data["_BASE_"]
        base_config_path = os.path.join(os.path.dirname(config_path), base_config_relpath)
        tmp_yaml_path_list = create_tmp_config(base_config_path)
        yaml_data["_BASE_"] = tmp_yaml_path_list[-1]  # The config files link to each other via the _BASE_ key
    else:
        tmp_yaml_path_list = []

    if checkpoint_path is not None:
        yaml_data["MODEL"]["WEIGHTS"] = checkpoint_path

    with open(tmp_yaml_path, "w") as f:
        yaml.dump(yaml_data, f, Dumper=Dumper)

    tmp_yaml_path_list.append(tmp_yaml_path)

    return tmp_yaml_path_list


def setup_cfg(input_config):
    """Setup the configuration for Mask2Former using the given input config file or list.

    Args:
        input_config (str, list, dict): Path to the config file, a list of config options (interleaved key,value),
        or a dictionary of config options.

    Returns:
        cfg (CfgNode): The Detectron2 configuration object with the given settings.
    """
    cfg = get_cfg()
    add_deeplab_config(cfg)
    add_maskformer2_config(cfg)

    if isinstance(input_config, str):
        cfg.merge_from_file(input_config)
    elif isinstance(input_config, list):
        cfg.merge_from_list(input_config)
    elif isinstance(input_config, dict):
        config_list = []
        for k, v in input_config.items():
            config_list.append(k)
            config_list.append(v)
        cfg.merge_from_list(config_list)

    cfg.freeze()
    return cfg


def create_mask(predictions, labels, dilation_radius=0):
    """Create a binary mask image from the raw Mask2Former predictions.

    Args:
        predictions (dict): The raw predictions from the Mask2Former model, containing semantic segmentation results.
        labels (list): A list of label IDs to include in the mask.
        dilation_radius (int): Dilation radius to inflate the mask. Default is 0 (no dilation).

    Returns:
        np.ndarray: A binary mask array.
    """
    assert "sem_seg" in predictions, "The predictions must contain 'sem_seg' key with semantic segmentation results."

    segmentation = predictions["sem_seg"].argmax(dim=0).to("cpu").numpy()
    mask_bool = np.isin(segmentation, labels).reshape(segmentation.shape)

    if dilation_radius > 0:
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (dilation_radius * 2 + 1, dilation_radius * 2 + 1))
        mask_bool = cv2.dilate(mask_bool.astype(np.uint8) * 255, kernel, iterations=1).astype(bool)

    return mask_bool


if __name__ == "__main__":
    main()
